类初始化的时机

在类和接口被加载和连接的时机上, Java虚拟机规范给实现提供了一定的灵活性 。但是它严格地定义了初始化的时机 。所有的Java虚拟机实现必须在每个类或接口首次主动使用时初始化 。下面这几种情形必须立即对类进行“初始化”：

1)遇到 new、 getstatic、 putstatic或invokestatic这4条字节码指令时,如果类没有进行过初始化, 则需要先触发其初始化, 生成这4条指令的最常见的 Java代码场景是:

使用 new关键字实例化对象的时候
读取或设置一个类的静态字段的时候(即在字节码中,执行getstalic或putstatic指令时),被final修饰、已在编译期把结果放入常量池的静态字段除外
调用一个类的静态方法的时候(即在字节码中执行invokestatic指令时)。
2 ) 当调用Java API中的某些反射方法时, 比如类Class中的方法或者java.lang.reflect包的方法对类进行反射调用的时候, 如果类没有进行过初始化 , 则需要先触发其初始化。

3 ) 当初始化一个类的时候, 如果发现其父类还没有进行过初始化, 则需要先触发其父类的初始化。

4) 当虚拟机启动时, 用户需要指定一个要执行的主类(包合 main()方法的那个类) . 虚拟机会先初始化这个主类。

5）当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果是REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。

对于这五种会触发类进行初始化的场景, 虚拟机规范中使用了一个很强烈的限定语:“有且只有 '', 这5种场景中的行为称为对一个类进行主动引用 。 除此之外，所有引用类的方式都不会触发初始化, 称为被动引用。



1、类加载过程

![类加载过程](\imgs\jvm\jvm类加载过程.jpg)

加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序进行，而解析阶段则不一定，它在某些情况下可能在初始化阶段后在开始，因为java支持运行时绑定。

2、加载阶段

 **在加载阶段，虚拟机需要完成以下3件事情：**

通过一个类的全限定名来获取定义此类的二进制字节流
将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

 **加载.class文件的方式**

从本地系统中直接加载
通过网络下载.class文件
从zip，jar等归档文件中加载.class文件
从专有数据库中提取.class文件
将Java源文件动态编译为.class文件    

​    相对于类生命周期的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。
3、连接阶段

3.1 验证：确保被加载的类的正确性

    确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

文件格式验证：验证字节流是否符合Class文件格式的规范，如：是否以魔数0xCAFEBABE开头、主次版本号是否在当前虚拟机处理范围内等等。
元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求；如：这个类是否有父类，是否实现了父类的抽象方法，是否重写了父类的final方法，是否继承了被final修饰的类等等。
字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的，如：操作数栈的数据类型与指令代码序列能配合工作，保证方法中的类型转换有效等等。
符号引用验证：确保解析动作能正确执行；如：通过符合引用能找到对应的类和方法，符号引用中类、属性、方法的访问性是否能被当前类访问等等。
    验证阶段是非常重要的，但不是必须的。可以采用-Xverify:none参数来关闭大部分的类验证措施。

  3.2 准备：为类的静态变量分配内存，并将其赋默认值

    为类变量分配内存并设置类变量初始值，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：

只对static修饰的静态变量进行内存分配、赋默认值（如0、0L、null、false等）。
对final的静态字面值常量直接赋初值（赋初值不是赋默认值，如果不是字面值静态常量，那么会和静态变量一样赋默认值）。
  3.3 解析：将常量池中的符号引用替换为直接引用（内存地址）的过程

    符号引用就是一组符号来描述目标，可以是任何字面量。属于编译原理方面的概念如：包括类和接口的全限定名、字段的名称和描述符、方法的名称和描述符。
    
    直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。如指向方法区某个类的一个指针。
    
    假设：一个类有一个静态变量，该静态变量是一个自定义的类型，那么经过解析后，该静态变量将是一个指针，指向该类在方法区的内存地址。
4、初始化：为类的静态变量赋初值

  赋初值两种方式：

- 定义静态变量时指定初始值。如 private static String x="123";
- 在静态代码块里为静态变量赋值。如 static{ x="123"; } 

  注意：只有对类的主动使用才会导致类的初始化。

5、clinit 与 init

在编译生成class文件时，编译器会产生两个方法加于class文件中，一个是类的初始化方法clinit, 另一个是实例的初始化方法init。

  5.1 clinit 

clinit指的是类构造器，主要作用是在类加载过程中的初始化阶段进行执行，执行内容包括静态变量初始化和静态块的执行。

注意事项：

1. 如果类中没有静态变量或静态代码块，那么clinit方法将不会被生成。

2. 在执行clinit方法时，必须先执行父类的clinit方法。

3. clinit方法只执行一次。

3. static变量的赋值操作和静态代码块的合并顺序由源文件中出现的顺序决定。如下代码所示：

```java
public class TestClass {
    public static void main(String[] args) {
        ClassInit init=ClassInit.newInstance();
 
        System.out.println(init.x);
        System.out.println(init.y);
    }
}
 
class ClassInit{
    private static ClassInit init=new ClassInit();
    public static int x;
    public static int y=0;
    static{
        x++;
        y++;
    }
    private ClassInit(){
        x++;
        y++;
    }
    public static ClassInit newInstance(){
        return init;
    }
}
//在类加载到连接完成阶段，ClassInit类在内存中的状态为：init=null,x=0,y=0
//初始化阶段时，需要执行clinit方法，该方法类似如下伪代码：
clinit(){
	//init=new ClassInit();调用构造方法
    x++;//x=1 因为此时x的值为连接的准备阶段赋的默认值0，然后++变成1
    y++;//y=1 因为此时y的值为连接的准备阶段赋的默认值0，然后++变成1
    //x=0;//为什么这里没有执行x=0，因为程序没有给x赋初值，因此在初始化阶段时，不会执行赋初值操作
    y=0;//因为类变量y在定义时，指定了初值，尽管初值为0，因此在初始化阶段的时候，需要执行赋初值操作
    x++;//第一个静态块的自增操作，结果为x=2;
    y++;//第一个静态块的自增操作，结果为y=1;
}
//所以最终结果为x=2,y=1
//如果private static ClassInit init=new ClassInit(); 代码在public static int y=0;后面，那么clinit方法的伪代码如下：
clinit(){
    //x=0;//这里虽然没有执行，但此时x的值为连接的准备阶段赋的默认值0
    y=0;//因为类变量y在定义时，指定了初值，尽管初值为0，因此在初始化阶段的时候，需要执行赋初值操作
	//init=new ClassInit();调用构造方法
    x++;//x=1 因为此时x的值为连接的准备阶段赋的默认值0，然后++变成1
    y++;//y=1 因为此时y的值为初始化阶段赋的初值，只是这个初值刚好等于默认值0而已，然后++变成1
    x++;//第一个静态块的自增操作，结果为x=2;
    y++;//第一个静态块的自增操作，结果为y=2;
}
//最终结果为x=2,y=2
```

  5.1 init

init指的是实例构造器，主要作用是在类实例化过程中执行，执行内容包括成员变量初始化和代码块的执行。

注意事项：

1. 如果类中没有成员变量和代码块，那么init方法将不会被生成。

2. 在执行init方法时，必须先执行父类的init方法。

3. init方法每实例化一次就会执行一次。

3. init方法先为实例变量分配内存空间，再执行赋默认值，然后根据源码中的顺序执行赋初值或代码块。如下代码所示：

```java
public class TestClass {
    public static void main(String[] args) {
        ClassInit init=new ClassInit();
    }
}
 
class ClassInit{
    public int x;
    public int y=111;
    public ClassInit(){
        x=1;
        y=1;
    }
    {
        x=2;
        y=2;
    }
    {
        x=3;
        y=3;
    }
}
//实例化步骤为：先为属性分配空间，再执行赋默认值，然后按照顺序执行代码块或赋初始值，最后执行构造方法
//根据上述代码，init方法的伪代码如下：
init(){
	x=0;//赋默认值
    y=0;//赋默认值
    y=111;//赋初值
    x=2;//从上到下执行第一个代码块
    y=2;//从上到下执行第一个代码块
    x=3;//从上到下执行第二个代码块
    y=3;//从上到下执行第二个代码块
    //ClassInit();执行构造方法
    x=1;//最后执行构造方法
    y=1;//最后执行构造方法
}
//如果上述代码的成员变量x,y的定义在类最后时，那么init方法的伪代码如下：
init(){
	x=0;//赋默认值
    y=0;//赋默认值
    x=2;//从上到下执行第一个代码块
    y=2;//从上到下执行第一个代码块
    x=3;//从上到下执行第二个代码块
    y=3;//从上到下执行第二个代码块
    y=111;//赋初值
    //ClassInit();执行构造方法
    x=1;//最后执行构造方法
    y=1;//最后执行构造方法
}
```

6、卸载阶段

  执行了System.exit()方法

  程序正常执行结束

  程序在执行过程中遇到了异常或错误而异常终止

  由于操作系统出现错误而导致Java虚拟机进程终止