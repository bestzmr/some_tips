

1.Spring AOP有用到了动态代理，那你说说看AOP用到了哪种方式？

在Spring中默认使用的是JDK动态代理，除非目标类没有实现接口，才会转为CGLIB代理，如果想要强行使用CGLIB代理免责需要在Spring配置文件中加入`<aop:aspectj-autoproxy proxy-target-class="true" />`，

然而在SpringBoot中，从2.0开始就默认使用CGLIB代理。

2.反射的缺点时对性能有影响，这类操作总是慢于直接执行java代码，那请问怎么解决这个问题？

* 在系统启动时，将反射得到元数据保存起来，使用时，只需从内存中调用即可。

* 尽量用高点的JDK，因为高版本的虚拟机会对执行次数较多的方法进行优化，例如使用jit技术，而低版本的那个时候还没实现，

* 可以考虑使用高性能的反射库，Spring内部也有提供一些。

3.Java.lang.annotation 提供了四种元注解，是哪四种？有什么用呢？

- @Target：注解的作用目标
- @Retention：注解的生命周期
- @Documented：注解是否应当被包含在 JavaDoc 文档中
- @Inherited：是否允许子类继承该注解

4.@Retention注解的生命周期有哪几种？有什么区别？

- etentionPolicy.SOURCE：当前注解编译期可见，不会写入 class 文件
- RetentionPolicy.CLASS：类加载阶段丢弃，会写入 class 文件
- RetentionPolicy.RUNTIME：永久保存，可以反射获取

5.父类使用了注解，请问子类继承了这个父类后，是否也携带了这个注解呢？如果没有，要怎么实现这个过程？

在注解上使用元注解@Inherited，表示该注解会被子类所继承，注意该注解仅针对类，成员、方法并不受该元注解的影响。因此，如果想要让子类也继承父类的注解，则需要给注解加上元注解@Inherited。

6.HashMap为什么线程不安全？

HashMap线程不安全原因：

原因：

- **JDK1.7 中，由于多线程对HashMap进行扩容，调用了HashMap#transfer()，具体原因：某个线程执行过程中，被挂起，其他线程已经完成数据迁移，等CPU资源释放后被挂起的线程重新执行之前的逻辑，数据已经被改变，造成死循环、数据丢失。**（**JDK1.7 HashMap线程不安全体现在：死循环、数据丢失**）
- **JDK1.8 中，由于多线程对HashMap进行put操作，调用了HashMap#putVal()，具体原因：假设两个线程A、B都在进行put操作，并且hash函数计算出的插入下标是相同的，当线程A执行完第六行代码后由于时间片耗尽导致被挂起，而线程B得到时间片后在该下标处插入了元素，完成了正常的插入，然后线程A获得时间片，由于之前已经进行了hash碰撞的判断，所有此时不会再进行判断，而是直接进行插入，这就导致了线程B插入的数据被线程A覆盖了，从而线程不安全。**（**JDK1.8 HashMap线程不安全体现在：数据覆盖**）

7.线程之间的通信机制有哪些呢？Java的并发采用的是哪种？

线程之间的通信机制可以分为两种，分别是

- 共享内存
- 消息传递

目前Java的并发通信采用的是共享内存的方式。

8.说说JMM对内存的划分？

JMM规定了内存主要划分为主内存和工作内存两种，规定所有的变量都存储在主内存中，每个线程还有自己的工作内存，线程的工作内存中保存了该线程中用到的变量的主内存的副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。

不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。



9.你说说看什么是内存模型？有什么存在作用？

JMM其实并不像JVM内存模型一样是真实存在的，它只是一个抽象的规范。在不同的硬件或者操作系统下，对内存的访问逻辑都有一定的差异，而这种差异会导致同一套代码在不同操作系统或者硬件下，得到了不同的结果，而JMM的存在就是为了解决这个问题，通过JMM的规范，保证Java程序在各种平台下对内存的访问都能得到一致的效果。



10.工作内存和主内存指的是啥？

工作内存和主内存其实跟JVM内存的划分是在不同层次上进行的，是自己的一套抽象概念，大概可以理解为，主内存对应的是Java堆中的对象实例部分，而工作内存对应的则是栈中的部分区域。

11.讲解一下什么是happens-before原则

我们编写的程序都要经过优化后（编译器和处理器会对我们的程序进行优化以提高运行效率）才会被运行，优化分为很多种，其中有一种优化叫做重排序，**重排序需要遵守happens-before规则，不能说你想怎么排就怎么排，如果那样岂不是乱了套。**

happens-before部分规则如下：

1、程序顺序规则：一个线程中的每个操作happens-before于该线程中的任意后续操作

2、监视器锁（同步）规则：对于一个监视器的解锁，happens-before于随后对这个监视器的加锁

**程序顺序规则中所说的每个操作happens-before于该线程中的任意后续操作并不是说前一个操作必须要在后一个操作之前执行，而是指前一个操作的执行结果必须对后一个操作可见，如果不满足这个要求那就不允许这两个操作进行重排序**

**二、**例：下面的方法的功能是计算一个长方形面积

```java
	public double rectangleArea(double length , double width){
		double leng;
		double wid;
		leng=length;//A
		wid=width;//B
		double area=leng*wid;//C
		return area;
	}
```

上面的操作在运行之前编译器和处理器可能会进行优化

在程序中

A happens-before B

B happens-before C

A happens-before C //happens-before具有传递规则

根据happens-before规则我们来分析重排序后可能产生的结果

因为A happens-before B，所以A操作产生的结果leng一定要对B操作可见，但是现在B操作并没有用到length，所以这两个操作可以重排序，那A操作是否可以和C操作重排序呢，如果A操作和C操作进行了重排序，因为leng没有被赋值，所以leng=0，area=0*wid也就是area=0；这个结果显然是错误的，所以A操作是不能和C操作进行重排序的（这就是注2中说的前一个操作的执行结果必须对后羿操作可见，如果不满足这个要求就不允许这两个操作进行重排序）

12.成员内部类为什么不能定义静态变量

```java

public class InnerClassDemo {
 
	class InnerClass{
		//1、这样是可以的，这样编译器会在编译的时候就将这种语句变成常量值（也就是说可以定义所有的static final + 基本数据类型）
		static final int i = 50;
		//2、这样不可以，虽然也为static final 但是说到底还是个变量对象，所以不可以这样
		static final String str = new String("");
		//3、与上相同
		static InnerClass innerClass = new InnerClass();
	}
	
}
```

其实内部类并不是完全不能出现static 这样的修饰的，只要符合第一种情况的就是可以的。

而第二种，第三种的情况肯定是不行的，为什么？

就用第三种情况来做个反证，假如说允许第三种情况出现。

那么根据初始化的流程我们知道，在类加载的时候，static变量就会被初始化，那么我们InnerClass对象在没有InnerClassDemo这个对象的时候便生成了。。这样这个成员内部类就脱离了外部类的掌控，不需要外部类的对象就可以生成内部类的对象，这与成员内部类的定义就相驳了，因为我们知道成员内部类的对象必须是现有外部类的对象才能创建，并且是绑定在一起的，所以成员内部类不可以定义静态变量。


13.静态内部类的加载时机？他和外部类的加载有没有什么关系？

静态内部类的加载是在程序中调用静态内部类的时候加载的，和外部类的加载没有必然关系，

但是在加载静态内部类的时候 发现外部类还没有加载，那么就会先加载外部类，

加载完外部类之后，再加载静态内部类（初始化静态变量和静态代码块etc）

如果在程序中单纯的使用 外部类，并不会触发静态内部类的加载

扩展：

①一个类内部有静态内部类和非静态内部类 ， 静态内部类和非静态内部类一样，都是在被调用时才会被加载 

不过在加载静态内部类的过程中如果没有加载外部类，也会加载外部类

静态变量，静态方法，静态块等都是类级别的属性，而不是单纯的对象属性。

他们在类第一次被使用时被加载 （记住，是一次使用，不一定是实例化）

我们可以简单得用 类名.变量 或者 类名.方法来调用它们

 与调用没有被static 修饰过变量和方法不同的是：一般变量和方法是用当前对象的引用（即this）来调用的， 静态的方法和变量则不需要。从一个角度上来说，它们是共享给所有对象的，不是一个角度私有。 这点上，静态内部类也是一样的。

② 类的加载时机：（暂时的认知里是四种） new 一个类的时候，调用类内部的 静态变量，调用类的静态方法，调用类的 静态内部类
