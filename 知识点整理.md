

1.Spring AOP有用到了动态代理，那你说说看AOP用到了哪种方式？

在Spring中默认使用的是JDK动态代理，除非目标类没有实现接口，才会转为CGLIB代理，如果想要强行使用CGLIB代理免责需要在Spring配置文件中加入`<aop:aspectj-autoproxy proxy-target-class="true" />`，

然而在SpringBoot中，从2.0开始就默认使用CGLIB代理。

2.反射的缺点时对性能有影响，这类操作总是慢于直接执行java代码，那请问怎么解决这个问题？

* 在系统启动时，将反射得到元数据保存起来，使用时，只需从内存中调用即可。

* 尽量用高点的JDK，因为高版本的虚拟机会对执行次数较多的方法进行优化，例如使用jit技术，而低版本的那个时候还没实现，

* 可以考虑使用高性能的反射库，Spring内部也有提供一些。

3.Java.lang.annotation 提供了四种元注解，是哪四种？有什么用呢？

- @Target：注解的作用目标
- @Retention：注解的生命周期
- @Documented：注解是否应当被包含在 JavaDoc 文档中
- @Inherited：是否允许子类继承该注解

4.@Retention注解的生命周期有哪几种？有什么区别？

- etentionPolicy.SOURCE：当前注解编译期可见，不会写入 class 文件
- RetentionPolicy.CLASS：类加载阶段丢弃，会写入 class 文件
- RetentionPolicy.RUNTIME：永久保存，可以反射获取

5.父类使用了注解，请问子类继承了这个父类后，是否也携带了这个注解呢？如果没有，要怎么实现这个过程？

在注解上使用元注解@Inherited，表示该注解会被子类所继承，注意该注解仅针对类，成员、方法并不受该元注解的影响。因此，如果想要让子类也继承父类的注解，则需要给注解加上元注解@Inherited。

6.HashMap为什么线程不安全？

HashMap线程不安全原因：

原因：

- **JDK1.7 中，由于多线程对HashMap进行扩容，调用了HashMap#transfer()，具体原因：某个线程执行过程中，被挂起，其他线程已经完成数据迁移，等CPU资源释放后被挂起的线程重新执行之前的逻辑，数据已经被改变，造成死循环、数据丢失。**（**JDK1.7 HashMap线程不安全体现在：死循环、数据丢失**）
- **JDK1.8 中，由于多线程对HashMap进行put操作，调用了HashMap#putVal()，具体原因：假设两个线程A、B都在进行put操作，并且hash函数计算出的插入下标是相同的，当线程A执行完第六行代码后由于时间片耗尽导致被挂起，而线程B得到时间片后在该下标处插入了元素，完成了正常的插入，然后线程A获得时间片，由于之前已经进行了hash碰撞的判断，所有此时不会再进行判断，而是直接进行插入，这就导致了线程B插入的数据被线程A覆盖了，从而线程不安全。**（**JDK1.8 HashMap线程不安全体现在：数据覆盖**）

