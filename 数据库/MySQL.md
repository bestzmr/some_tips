### 关系型数据库和非关系型数据库的区别
* 关系型数据库
    * 表和表、表和字段、数据和数据存在着关系
    * 优点：
        * 数据之间有关系，进行数据的增删改查的时候是非常方便的
        * 关系型数据库是有事务操作的，保证数据的完整性和一致性。
    * 缺点：
        * 因为数据和数据是有关系的，底层是运行了大量的算法
            大量算法会降低系统的效率，会降低性能
        * 面对海量数据的增删改查的时候会显的无能为力
        * 海量数据对数据进行维护变得非常的无力
* 非关系型数据库
    * 为了处理海量数据，非关系数据库设计之初就是为了替代关系型数据库的关系
    * 优点：
        * 海量数据的增删改查是可以的
        * 海量数据的维护和处理非常轻松
    * 缺点：
        * 数据和数据没有关系，他们之间就是单独存在的
        * 非关系数据库没有关系，没有强大的事务关系，没有保证数据的完整性和安全性

### 简述 left join、right join 以及inner join 的区别
* left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录 
* right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录
* inner join(等值连接) 只返回两个表中联结字段相等的行

### 存储引擎
* Innodb:
    * MySQL 5.5版本后默认的存储引擎为InnoDB。
    * 支持事务，支持外键，行锁，查表总行数时，全表扫描  
* MYISAM:
    * MyISAM是MySQL的默认数据库引擎（5.5版之前）
    * 不支持事务，不支持外键，表锁，插入数据时，锁定整个表，查表总行数时，不需要全表扫描
    * 由于不支持事务和行级锁，最大的缺陷就是崩溃后无法安全恢复
* MEMORY:
    * 所有数据置于内存的存储引擎，拥有极高的插入，更新和查询效率。但是会占用和数据量成正比的内存空间。并且其内容会在Mysql重新启动时丢失 
* Merge：
    * 将一定数量的MyISAM表联合而成一个整体，在超大规模数据存储时很有用 
* Archive：
    * 非常适合存储大量的独立的，作为历史记录的数据。因为它们不经常被读取。Archive拥有高效的插入速度，但其对查询的支持相对较差 

### SQL语句的分类
* DDL(Data definition Language)数据库定义语言:create、alter、drop，定义和改变表的结构
* DML(Data Manipulation Language)数据库操作语言：insert、update、delete，对数据库中的数据进行操作
* DCL(Data Control Language)数据库控制语言，grant，revoke，设置和更改数据库用户或者角色权限。

### 写出几种MySQL内置函数(数字、字符串、日期)
* 字符串函数
```
concat(str1,str2,...) - 把参数连成一个长字符串并返回(任何参数是null时返回null)  
substring(str,pos,len) - 返回字符串str的位置pos起len个字符  
locate(substr,str) - 返回字符串substr在字符串str第一次出现的位置(str不包含substr时返回0)  
length(str)  - 返回字符串的长度,一个汉字是算三个字符，一个数字或字母算一个字符。
reverse(str) - 颠倒字符串str的字符顺序并返回
insert(str,pos,len,newstr) - 把字符串str由位置pos起len个字符长的子串替换为字符串
```
* 数字函数
```
abs(n) - 求绝对值
mod(n,m) - 取模运算,返回n被m除的余数(同%操作符)
floor(n) - 返回不大于n的最大整数值  
round(n,d) - 返回n的四舍五入值,保留d位小数(d的默认值为0)
pi() - 返回圆周率  
truncate(n,d) - 保留数字n的d位小数并返回 
```
* 日期函数
```
dayofweek(date) - 返回日期date是星期几(1=星期天,2=星期一,……7=星期六,odbc标准)  
year(date) - 返回date的年份(范围在1000到9999)    
dayofmonth(date) - 返回date是一月中的第几日(在1到31范围内)   
second(time) - 返回time的秒数(范围是0到59) 
curdate() - 以'yyyy-mm-dd'或yyyymmdd格式返回当前日期值(根据返回值所处上下文是字符串或数字) 
now() - 以'yyyy-mm-dd hh:mm:ss'或yyyymmddhhmmss格式返回当前日期时间(根据返回值所处上下文是字符串或数字)     
```
* 日期函数和字符串函数的相互转换
```
字符串转换成数字
方法一：SELECT CAST('123' AS SIGNED);
方法二：SELECT '123'+0;//亲测有效
方法三：SELECT CONVERT('123',SIGNED);
=======
数字转换成字符串
使用concat函数

日期转换成字符串使用date_format函数
字符串转换成日期str_to_date(str,format)；注:format格式必须和str的格式相同，否则返回空
```

### 查找一条比较慢的语句
* MySQL在Windows系统中的配置文件一般是是my.ini找到[mysqld]下面加上
```
log-slow-queries = F:/MySQL/log/mysqlslowquery。log
long_query_time = 2 // 当SQL语句执行时间超过此数值时，就会被记录到日志中，建议设置为1或者更短。
```


### MySQL的主键
* 主键是用来唯一确定表中每一行数据的标识符
* 主键可以是表中的某一列或者多列的组合，其中由多列组合的主键称为复合主键
* 在创建表的时候需要设置一个主键约束,使用primary key关键字来指定
* 在MySQL5.5版本之后要求表必须有一个主键,如果没有显示的指定,MySQL会自动选择一个可以唯一标识数据的列作为主键,如果不存在这样的列,MySQL会自动为InnoDB表生成一个隐含字段作为主键,类型时长整型.

### MySQL的外键
* 外键是指引用另外一个表中的一列或多列数据，被引用的列应该具有主键约束或者唯一性约束。外键用来建立和加强两个表数据之间的连接。
* 添加外键使用foreign key关键字来指定;
* 在一对多关系的两张表中使用外键时,需要在多的一方指定外键
* 如果两张表存在着外键关系,需要先删除拥有外键所在表的记录,再删除需要删除的记录.


### 数据库设计的三大范式
* 1NF：原子性，数据库表的每一列都是不可再分割的；
* 2NF：在1NF的基础上，非关键列要全部依赖于关键列
* 3NF：在2NF的基础上，不存在非关键列的传递函数依赖于关键列，也就是说所有的非关键列要直接依赖于关键列。

### 项目中表是怎么设计的

### 什么是事务？事务的四大特性（ACID）
* 事务：事务是一组相关操作的SQL语句的集合，我们所有的操作都是处在事务中的，事务是数据库的执行业务的基本单位。
* 原子性(atomic):事务是不可再分割的，要么同时成功，要么同时失败
* 一致性(consistency)：事务一旦结束，内存中的数据要和数据库中的数据保持一致
* 隔离性(isolation)：事务之间互不干扰，一个事务的结束意味着另外一个事务的开启
* 持久性(duration)：事务提交到数据库中后，进行永久保存

### 事务的隔离级别
* READ_UNCOMMITED(读未提交)：
    事务的最低隔离级别，允许另外一个事务可以看到这个事务没有提交的数据，会出现脏读、不可重复读、幻读
* READ_COMMITED(读已提交)：保证一个事务修改完数据之后才会被另外一个数据读取到，即另外一个事务不能读取到该事务中正在修改的数据。会出现幻读和不可重复读
* REPEATABLE_READ(可重复读)：保证一个事务多次读取到的数据是一致的。会出现幻读
* SERIALIABLE(可序列化)：事务被顺序执行，类似于锁表，性能比较低下。

### 事务的并发处理机制
* 脏读：一个事务正在修改表中的记录，但这个操作还没有提交，此时另外一个事务访问并使用了表中的该记录。
* 不可重复读：一个事务多次访问表中的记录，此时另外一个事务访问并修改了表中的记录。导致第一个事务多次读取到的结果不一样。
* 幻读：一个事务正在修改表中的记录，另外一个事务向表中插入记录，第一个事务就会发现还有没有修改的记录，向出现幻觉一样


### 什么是索引，索引的数据结构(B+树)
* 索引就是加快检索表中数据的方法，数据库中的索引就相当于书籍索引，在书籍中，索引允许用户不必翻阅完整个书就能迅速地找到所需要的信息。在数据库中，索引也允许数据库程序迅速找到表中的数据，而不会去扫描整张表。
* 索引的数据结构
    * MySQL使用的是B+树作为索引的数据结构的。
    * B+树：
        * 从根节点到叶节点的所有路径都距离相同的长度
        * 所有的数据信息都存储在叶子节点上，非叶子节点作为叶节点的索引存在
        * 根节点上至少拥有两个子树，每个树节点最多拥有M个子树，至少拥有M/2个子树
    * B+树是为了磁盘及其其他存储辅助设备而设计的一个平衡查找树，在B+树中，所有记录的节点按照大小顺序存放在同一层的叶节点中，各叶子节点用指针进行连接。

### MySQL中索引的分类
* 普通索引：同表中的普通列作为索引，没有任何限制
* 唯一索引：建立索引列的值必须是唯一的，可以为空
* 主键索引：根据主键建立索引，不允许重复，不能为空
* 全文索引：为文本生成单词的清单，在索引时根据单词的清单进行索引。

### 建立索引的优缺点
* 优点[作用]：
    * 加快数据库的检索速度
    * 降低了增删改等操作的效率
    * 加速了表与表之间的连接
    * 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。
* 缺点:
    * 创建和维护索引需要耗费时间，
    * 索引需要耗费物理空间
    * 对表中的数据进程增删改操作时，索引也要进行维护，这样就降低了数据的维护速度。


### 什么字段适合添加索引
* 该字段所在的列经常进行搜索操作
* 作为主键的列上，强制该列的唯一性和组织表中数据的排列结构
* 经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度。
* 在经常需要排列的列上创建索引，由于索引以及排序，可以加快排序查询时间


### 使用索引查询一定能提高查询的性能吗？
* 不一定
* 索引是需要空间来存储的，也需要定期维护的。每当有记录在表中增删改索引列时，索引本身也会修改，这就意味着每条记录的INSERT,DELETE和UPDATE将为此多付出磁盘的I/O，因为索引需要额外的存储空间来处理，那些不必要的索引反而使查询时间反应慢
* 索引范围适合两种情况
    * 平均数据范围符合条件用索引比全表扫描差，因为选择性不高
    * 对于符合条件数据量小的，使用索引效率会高很多。

### 索引失效情况
* 使用like进行模糊查询
* 查询条件中使用or会使索引失效，要想是索引生效，需要将or中的每个列都加上索引。
* 对索引列使用函数

### 索引的最左前缀法则
* 所谓最左前列，指的是查询从索引的最左前列开始，并且不跳过索引中的列

### 建立索引的规则
* 表的主键、外键必须有索引；
* 数据量超过300的表应该有索引；
* 经常与其他表进行连接的表，在连接字段上应该建立索引；
* 经常出现在Where子句中的字段，特别是大表的字段，应该建立索引；
* 索引应该建在选择性高的字段上；
* 索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引；
* 复合索引的建立需要进行仔细分析；尽量考虑用单字段索引代替
* 频繁进行数据操作的表，不要建立太多的索引；
* 删除无用的索引，避免对执行计划造成负面影响；

### 存储过程
* 存储过程是为了完成特定功能的SQL语句集，经编译之后存储在数据库中，用户通过指定存储过程的名字并给定参数来调用执行该存储过程，MySQL5.0开始支持存储过程

### 存储过程的优点
* **增强SQL语言的功能和灵活性**：存储过程可以用控制语句编写，有很强的灵活性，可以完成复杂的判断和较复杂的运算。
* **标准组件式编程**：存储过程被创建后，可以在程序中被多次调用，而不必重新编写该存储过程的SQL语句。而且数据库专业人员可以随时对存储过程进行修改，对应用程序源代码毫无影响。
* **较快的执行速度**：如果某一操作包含大量的Transaction-SQL代码或分别被多次执行，那么存储过程要比批处理的执行速度快很多。因为存储过程是预编译的。在首次运行一个存储过程时查询，优化器对其进行分析优化，并且给出最终被存储在系统表中的执行计划。而批处理的Transaction-SQL语句在每次运行时都要进行编译和优化，速度相对要慢一些。

### 存储过程和函数的区别
* 函数只能返回一个变量，而存储过程可以返回多个
* 存储过程的参数有IN,OUT,INOUT三种类型，而函数之后IN一个
* 存储过程不需要声明返回类型，函数在声明时需要描述返回类型，且函数体中必须包含一个有效的RETURN语句
* 存储过程一般作为一个独立部分来执行，而函数可以作为SQL语句的一部分来调用


### 什么是视图？为什么要使用视图
* 视图是指计算机数据库中的视图，是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。
* 关系型数据库中的数据是由一张一张的二维关系表所组成，简单的单表查询只需要遍历一个表，而复杂的多表查询需要将多个表连接起来进行查询任务。对于复杂的查询事件，每次查询都需要编写MySQL代码效率低下。为了解决这个问题，数据库提供了视图（view）功能。
```
-- 视图是一张"虚拟"表
create view student_view
as select sno,sname,sgender from student;

-- 查询视图
mysql>select * from student_view;

-- 删除视图
mysql>drop view student_view;
```


### 视图的作用
* 当需要进程多表查询时提供了SQL语句的重用性
* 对象数据库进程重构，但不影响程序的运行
* 提高了安全性能，可以对不同的用户设定不同的视图

### 视图的WITH CHECK OPTION
* 如果视图在创建时指定了"WITH CHECK OPTION",那么更新数据时不能插入或者更新不符合视图限制条件的记录。

### 表的复制
* 创建一个真实存在的表，与原来的表互不干扰，得到的表保留了原表的结构和数据
```
-- 创建了一个真实的表student_copy
-- 它和student互不影响的
-- student_copy表保留了student表的结构和数据.
create table student_copy
as
select * from student;

-- 只希望保留student表的结构,而不需要数据
create table student_copy2
as
select * from student where 1=2;
```
### limit的用法
* limit可以强制select语句返回的记录个数
* limit接受一个或者两个参数，参数必须是一个整数常量，如果给定两个参数，第一个参数指定返回返回记录行的偏移量，第二个参数是从偏移量开始的具体数量，初始化的偏移量是0

### limit的效率怎么样
* 当数据库的数量比较大，但是配合where只需要查询一部分数据的时候，执行效率比较高
* 当使用limit来查询数据，尤其是偏移量比较大的时候，效率也是很低的

### DML默认加的什么锁？
* 行级排它锁


### InnoDB引擎的锁机制
* 共享锁[S]--允许一个事务去读取一行，阻止其他事务去获取数据集的排它锁，共享锁就是我读的时候，另外一个人可以读，但不能写
* 排它锁[X]-- 允许获取排它锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排它写锁，排它锁就是我读的时候，另外一个人不能读也不能写
* 意向共享锁[IS]-- 事务打算给数据行加共享锁，必须先取得该表的IS锁
* 意向排它锁[IX]-- 事务打算给数据加行排它锁，必须先取得该表的IX锁

**注意**：
* 共享锁和排它锁都是行锁，意向锁都是表锁，应用中我们只会用到共享锁和排它锁，意向锁是mysql内部使用的，不需要用户干预
* 对于DML语句，InnoDB会自动给涉及数据集加排它锁，对于DQL语句，InnoDB不会加任何锁，事务可以通过在select后面添加 LOCK IN SHARE MODEL来加共享锁，通过在select后面添加FOR UPDATE来加排它锁

### drop、delete和truncate的区别
* delete属于DML语句，drop和truncate属于DDL语句
* drop删除的是整张表，delete和truncate只会删除表中的数据，但会保留表结构
* 从速度上来看，drop>truncate>delete
* 当不需要一张表的时候使用drop，当要删除表的部分记录的时候使用delete，当删除所有的数据只保留表结构的时候使用truncate。
* truncate不能和where结合起来使用,进行删除操作时不会进行存储,不会被回滚，delete可以和where结合起来使用,操作时原数据会被放到rollback segment中,可以被回滚

### char和vachar区别
* char 定义的列的长度是固定的，取值在0~255之间，varchar定义的列的长度是可变长字符串，取值在0~65535之间。

### 悲观锁和乐观锁
* 乐观锁--假设不会发生并发冲突，只有在数据提交的时候才会检查数据的完整性
* 悲观锁--假设会发生冲突，屏蔽一切违反数据完整性的操作


### SQL优化（详细，5种以上）
* 对查询进行优化，尽量避免全表扫描，在相应的列上加索引
* 尽量不要使用模糊查询，否则会放弃索引进行全表扫描
* 尽量避免使用or来连接条件，否则会放弃索引，进行全表扫描
* 使用in和not in也会进行全表扫描
* 尽量避免在 where子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描。
* 尽量避免在where子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描
* 尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。


### MySQL最小整数类型，占的字节
<table border="0"><colgroup><col><col></colgroup>
<tbody valign="top">
<tr>
<td>
<p>数据类型</p>
</td>
<td>
<p>说明</p>
</td>
</tr>
<tr>
<td>
<p>CHAR</p>
</td>
<td>
<p>1~255个字符的定长串，它的长度必须在创建时指定，否则MySQL假定为CHAR（1）</p>
</td>
</tr>
<tr>
<td>
<p>VARCHAR</p>
</td>
<td>
<p>可变长度，最多不超过255字节，如在创建时指定VARCHAR（n），则可存储0~n个字符的变长串</p>
</td>
</tr>
<tr>
<td>
<p>TINYTEXT</p>
</td>
<td>
<p>同TEXT，最大长度为255字节</p>
</td>
</tr>
<tr>
<td>
<p>MEDUIMTEXT</p>
</td>
<td>
<p>同TEXT，最大长度为16K</p>
</td>
</tr>
<tr>
<td>
<p>TEXT</p>
</td>
<td>
<p>最大长度为64K的变长文本</p>
</td>
</tr>
<tr>
<td>
<p>LONGTEXT</p>
</td>
<td>
<p>同Text，最大长度为4GB（纯文本，一般不会到4G）</p>
</td>
</tr>
<tr>
<td>
<p>ENUM</p>
</td>
<td>
<p>接受最多64K个串组成的预定义集合的某个串</p>
</td>
</tr>
<tr>
<td>
<p>SET</p>
</td>
<td>
<p>接受最多64K个串组成的预定义集合的零个或多个串</p>
</td>
</tr>
</tbody>
</table>